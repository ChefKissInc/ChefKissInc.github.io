---
title: ACPI
description: SSDT-с да додадете во вашиот Hackintosh EFI.
---

import Aside from '~/components/Aside.astro';

<Aside type="tip">
`Advanced Configuration and Power Interface`(ACPI) е отворен стандард што оперативните системи можат да го користат за откривање и конфигурирање на компјутерски хардверски компоненти, управување со енергија (на пр. исклучување USB контролер), автоматска конфигурација (на пр. Plug and Play, hot swapping) и следење на статусот.

Производителите можат да вршат проверки на оперативниот систем, што обично се прави за да се оневозможат некои уреди и други функционалности на ОС што немаат намера да ги поддржат.

Главната табела ACPI е `DSDT` (Differentiated System Description Table), дефинирајќи ги повеќето уреди. Потоа, тука се `SSDT` (Secondary System Description Tables), додавање дополнителни својства (на пр. `_PRW` (Power Resources for Wake) метод), дополнителни уреди, оневозможување на некои уреди врз основа на состојба итн.

Повеќето фирмвер ги дефинираат уредите во „DSDT“ и користат некои „SSDT“ за прилагодување на вредностите во зависност од инсталираниот хардвер и/или поставките на BIOS-от. Ако сте заинтересирани за ACPI, можете да ја прочитате спецификацијата ACPI наведена во [Спецификации на форумот UEFI] (https://uefi.org/specifications).

</Aside>

## Симнување SSDTTime

<Aside type="note" title="Дали знаете?">
Во минатото SSDT морало да се пишуваат рачно, но сега има автоматизирани алатки за овој процес. [`SSDTTime`](https://github.com/corpnewt/SSDTTime) и ќе се користи во овој водич.
</Aside>

Бидејќи „SSDTTime“ нема никакви изданија и е проект на Python, наместо тоа, преземете го изворниот код со кликнување на `Code` потоа `Download ZIP`.

![SSDTTime Страна за симнување](~/assets/SSDTTimeDownload.png)

## Користејќи SSDTTime

По извлекувањето на архивата, Windows корисниците треба да уклучат `SSDTTime.bat`.

Linux корисниците ќе мора да го отворат својот терминал во директориумот „SSDTTime“/`SSDTTime-master, а потоа да го стартуваат „python3 SSDTTime.py“. **Проверете дали имате инсталирано Python 3.**

macOS корисниците треба да користат „SSDTTime.command“.

По уклучавањето на алатката, таа автоматски ќе преземе `iASL`, која (де)компајлира ACPI табели. Потоа треба да бидете поздравени со следниот екран.

![SSDTTime конзолата](~/assets/SSDTTimeConsole.png)

### Одредување на ACPI на системот

Изберете ја опцијата `P` на целниот систем за да ги добиете ACPI табелите потребни за операциите во `SSDTTime`.

Ако не користите „SSDTTime“ на системот, наместо тоа, изберете „D“ за да ја изберете папката со табелите ACPI исфрлени од таа целна машина.

Сега софтверот треба да ги прикаже вчитаните табели на ACPI на врвот како на сликата од екранот подолу.

![SSDTTime](~/assets/SSDTTimeConsole_ACPILoaded.png)

### Генерирање на SSDTs

<Aside type="note">
Повеќето од овие "петчови" ќе се применуваат само на macOS и не треба да предизвикуваат никакви несакани ефекти на други оперативни системи
</Aside>

<details>
<summary>Информации за опциите</summary>

Во моментот на пишување, достапни се 12 опции

- `FixHPET`

  Ги поправа конфликтите на `IRQ` (Interrupt Request) во ACPI табелите. Овие конфликти може да предизвикаат хардверот, како што е звукот, да не работи правилно.

  <Aside type="danger">
  Не ја користете оваа опција на AMD, бидејќи може да предизвика повеќе штета отколку добро (trackpad-от да не работи, итн.).
  </Aside>

- `FakeEC`

  Создава лажен уред со вграден контролер за macOS да работи правилно **и** го оневозможува оригиналниот EC.

- `FakeEC Laptop`

  Создава лажен уред со вграден контролер за macOS да работи правилно, но **не** го оневозможува оригиналниот EC, бидејќи на лаптопите им е потребен за статус на батеријата, FN копчиња итн.

- `USBX`

  Создава USBX уред кој содржи својства за напојување на USB неопходни за правилна функционалност. Ова бара и валиден EC уред.

- `PluginType`

  Го поставува својството `plugin-type` на `1` на првото јадро на процесорот, овозможувајќи „X86PlatformPlugin“, што овозможува управување со енергијата на процесорот и графичката картичка (поддршката варира).
  Исто така, ги редефинира процесорите со објекти `Processor` наместо објекти `Device` доколку е потребно, бидејќи macOS не го поддржува поновиот стандард.

- `PMC`

  Го дефинира уредот `PMCR` на системи што го немаат за да дозволи поддршка за `NVRAM`.

- `RTCAWAC`

  Го оневозможува новиот `AWAC` (Alarm Wake ACPI Clock) и наместо тоа го овозможува `RTC` (Real-Time Clock).

- `USB Reset`

  Ги оневозможува уредите `RHUB` во ACPI за сите USB контролери да му дозволи на macOS правилно да ги набројува USB-портите на ACPI-системи со зафатен систем.

- `PCI Bridge`

  Ги дефинира PCI мостовите за патеката на уредот назначена со тоа што некои уреди можеби немаат дефинирани нивните PCI мостови, што ќе го направи OpenCore да не може да инјектира својства користејќи го копчето „DeviceProperties“ во конфигурацијата.

- `PNLF`

  Создава лажен „PNLF“ уред со „_UID“ што може да се избере од корисникот (во основа профилот што го користи) за да овозможи природна контрола на осветленоста на лаптопите.

  <Aside type="danger">
  На прв поглед може да изгледа дека поддржува AMD лаптопи, но не е исто како овој на страницата [NootedRed](/mk/applehax/nootedred/).
  Наместо тоа, користете го оној на гореспоменатата страница.
  </Aside>

- `XOSI`

  Се измамува како оперативен систем на Windows, дозволувајќи им на сите периферни уреди заклучени зад не-macOS да бидат активни на macOS.

- `Fix DMAR`

  Ги отстранува регионите на резервирана меморија од табелата „DMAR“. Потребно е да се добијат некои уреди како етернет контролери базирани на Intel I225 на Intel системи.

  <Aside type="danger">
  Ако веќе користите macOS 12.2.1 и подолу и имате етернет контролер базиран на Intel I225, ќе треба да ги отстраните `e1000=0` или `dk.e1000=0` од boot-args откако ќе го направите ова.
  </Aside>

</details>

**_Сите_** системи мора да го изберат подолу

- `USBX`,

  Изберете ја опцијата **default** (копче „Б“).

- `RTCAWAC`,

  Ако вели дека не ви треба, прескокнете го овој SSDT.

- `PluginType`,
- and `USB Reset`.

AMD **_десктопи_** мора **исто така** да го изберат следново

- `FakeEC`.

AMD **_лаптопи_** мора **исто така** да го изберат следново

- `FakeEC Laptop`,
- `XOSI`,

  Изберете **default** (копче „А“)

- и сите SSDT поврзани со задно осветлување потребни на страницата [NootedRed](/mk/applehax/nootedred/).

<details>
<summary>Пример на процедура</summary>
Базирано на ASRock B550m Phantom.

![SSDTTime FakeEC Резултат](~/assets/SSDTTime_FakeEC_Result.png)
![SSDTTime USBX Prompt](~/assets/SSDTTime_USBX_Prompt.png)
![SSDTTime USBX резултат](~/assets/SSDTTime_USBX_Result.png)
![SSDTTime PluginType резултат](~/assets/SSDTTime_PluginType_Result.png)
![SSDTTime RTCAWAC резултат](~/assets/SSDTTime_RTCAWAC_Result.png)
![SSDTTime USB Reset резултат](~/assets/SSDTTime_USBReset_Result.png)
![SSDTTime XOSI Prompt](~/assets/SSDTTime_XOSI_Prompt.png)
![SSDTTime XOSI резултат](~/assets/SSDTTime_XOSI_Result.png)

</details>

## Копирање на AML фајловите од Results папката 

Папката `Results` ќе изгледа слично на подолу откако ќе завршите.

![SSDTTime Results](~/assets/SSDTTimeResults.png)

Сега, копирајте ги сите датотеки што почнуваат со „SSDT“ и завршуваат на „.aml“ во папката `Results` во `Drive/EFI/OC/ACPI`.

### Спојување на OC петчовите користејќи PatchMerge

Конечно, спојте „patches_OC.plist“ со користење на скриптата „PatchMerge“ вклучена во „SSDTTime“. Стартувај го на ист начин како `SSDTTime`.

![PatchMerge](~/assets/PatchMerge.png)

Притиснете „1“ за да го изберете „Config.plist“ создаден во претходниот чекор, потоа повлечете го и испуштете го вашиот „Config.plist“ на прозорецот и притиснете enter.

![PatchMerge откако ќе го изберете „Config.plist“.](~/assets/PatchMerge_AfterSelect.png)

Потоа, притиснете „2“ за да започнете со процесот на спојување.

![PatchMerge по извршување на процесот на спојување](~/assets/PatchMerge_Result.png)

Изменетиот `Config.plist` со споени закрпи ќе се појави во папката `Results`.

Проверете дали е во ред, а потоа заменете го оригиналниот „Config.plist“ со новогенерираниот.
