---
title: ACPI
description: SSDT-файли для додавання до вашого EFI Hackintosh.
---

import Aside from '~/components/Aside.astro';

<Aside type="tip">
`Advanced Configuration and Power Interface` (ACPI) — це відкритий стандарт, який операційні системи можуть використовувати для виявлення та налаштування компонентів комп’ютерного обладнання, виконання керування живленням (наприклад, вимкнення контролера USB), автоматичного налаштування (наприклад, Plug and Play, гаряча заміна) та моніторингу стану.

Виробники можуть створювати перевірки операційної системи, що зазвичай робиться для відключення деяких пристроїв та інших функцій в ОС, які вони не мають наміру підтримувати.

Основною таблицею ACPI є `DSDT` (Differentiated System Description Table), яка визначає більшість пристроїв. Потім є `SSDT` (Secondary System Description Tables), які додають додаткові властивості (наприклад, метод `_PRW` (Power Resources for Wake)), додаткові пристрої, відключають деякі пристрої на основі умови тощо.

Більшість мікропрограм визначають пристрої в `DSDT` та використовують деякі `SSDT` для коригування значень залежно від встановленого обладнання та/чи налаштувань BIOS. Якщо вас цікавить ACPI, ви можете ознайомитися зі специфікацією ACPI, наведеною в [специфікаціях форуму UEFI](https://uefi.org/specifications).
</Aside>

## Завантаження SSDTTime

<Aside type="note" title="Чи знаєте ви?">
Раніше ці SSDT потрібно було писати вручну, але зараз існують автоматизовані інструменти для цього процесу. У цьому посібнику буде використано [`SSDTTime`](https://github.com/corpnewt/SSDTTime).
</Aside>

Оскільки `SSDTTime` не має жодних випусків і є проектом Python, завантажте вихідний код, натиснувши на `Code`, а потім `Download ZIP`.

![SSDTTime download page](~/assets/SSDTTimeDownload.png)

## Запуск SSDTTime

Після вилучення архіву користувачі Windows повинні запустити `SSDTTime.bat`.

Користувачі Linux повинні відкрити свій термінал у вилученій директорії `SSDTTime`/`SSDTTime-master`, а потім запустити `python3 SSDTTime.py`. **Переконайтеся, що у вас встановлено Python 3.**

Користувачі macOS повинні запустити `SSDTTime.command`.

Після запуску інструменту він автоматично завантажить `iASL`, який (де)компілює таблиці ACPI. Після цього вам має бути показано таке вікно.

![SSDTTime console](~/assets/SSDTTimeConsole.png)

### Вказівка ACPI цільової системи

Виберіть опцію `P` на цільовій системі, щоб зберегти таблиці ACPI, необхідні для роботи `SSDTTime`.

Якщо ви не запускаєте `SSDTTime` на цільовій системі, виберіть `D`, щоб вибрати папку зі збереженими таблицями ACPI з цієї цільової машини.

Програмне забезпечення тепер має показати завантажені таблиці ACPI зверху, як на скріншоті нижче.

![SSDTTime](~/assets/SSDTTimeConsole_ACPILoaded.png)

### Генерація SSDT

<Aside type="note">
Більшість цих патчів застосовуватимуться лише на macOS і не повинні викликати жодних побічних ефектів на інших операційних системах
</Aside>

<details>
<summary>Інформація про опції</summary>

На момент написання доступно 12 опцій

- `FixHPET`

  Виправляє конфлікти `IRQ` (Interrupt Request) у таблицях ACPI. Ці конфлікти можуть призвести до неправильної роботи деякого обладнання, такого як звук.

  <Aside type="danger">
  Не використовуйте цю опцію на AMD, оскільки це може завдати більше шкоди, ніж користі (не працює тачпад тощо).
  </Aside>

- `FakeEC`

  Створює фальшивий пристрій вбудованого контролера для коректної роботи macOS **та** відключає оригінальний EC.

- `FakeEC Laptop`

  Створює фальшивий пристрій вбудованого контролера для коректної роботи macOS, але **не** відключає оригінальний EC, оскільки ноутбукам він потрібен для стану батареї, клавіш FN тощо.

- `USBX`

  Створює пристрій USBX, який містить властивості живлення USB, необхідні для належної функціональності. Це також вимагає дійсного пристрою EC.

- `PluginType`

  Встановлює властивість `plugin-type` на `1` на першому ядрі процесора, увімкнувши `X86PlatformPlugin`, що дозволяє керувати живленням процесора та графічного процесора (підтримка різна).
  Він також перевизначає процесори за допомогою об’єктів `Processor` замість об’єктів `Device`, якщо потрібно, оскільки macOS не підтримує новіший стандарт.

- `PMC`

  Визначає пристрій `PMCR` на системах, де його немає, щоб дозволити підтримку рідного `NVRAM`.

- `RTCAWAC`

  Відключає новий `AWAC` (Alarm Wake ACPI Clock) та увімкне `RTC` (Real-Time Clock) замість нього.

- `USB Reset`

  Відключає пристрої `RHUB` в ACPI для всіх контролерів USB, щоб дозволити macOS правильно перераховувати порти USB на пошкоджених системах ACPI.

- `PCI Bridge`

  Визначає мости PCI для шляху до пристрою, оскільки деякі пристрої можуть не мати визначених мостів PCI, що призведе до неможливості введення властивостей OpenCore за допомогою ключа `DeviceProperties` у конфігурації.

- `PNLF`

  Створює фальшивий пристрій `PNLF` з вибраним користувачем `_UID` (в основному профіль, який він використовує), щоб дозволити рідне керування яскравістю на ноутбуках.

  <Aside type="danger">
  На перший погляд може здатися, що він підтримує ноутбуки AMD, але це не те саме, що на сторінці [NootedRed](/uk/applehax/nootedred/).
  Замість цього використовуйте той, що на вищезгаданій сторінці.
  </Aside>

- `XOSI`

  Підробляє операційну систему під Windows, дозволяючи будь-яким периферійним пристроям, заблокованим за межами macOS, бути активними на macOS.

- `Fix DMAR`

  Видаляє зарезервовані області пам’яті з таблиці `DMAR`. Це необхідно для отримання деяких пристроїв, таких як мережеві контролери на базі Intel I225 на системах Intel.

  <Aside type="danger">
  Якщо ви вже використовуєте macOS 12.2.1 та нижче та мережевий контролер на базі Intel I225, вам потрібно буде видалити `e1000=0` або `dk.e1000=0` з ваших аргументів завантаження після цього.
  </Aside>

</details>

**_Всі_** системи повинні вибрати наступне

- `USBX`,

  Виберіть опцію за **замовчуванням** (клавіша `B`).

- `RTCAWAC`,

  Якщо написано, що вам це не потрібно, пропустіть цей SSDT.

- `PluginType`,
- та `USB Reset`.

AMD **_настільні ПК_** повинні також вибрати наступне

- `FakeEC`.

AMD **_ноутбуки_** повинні також вибрати наступне

- `FakeEC Laptop`,
- `XOSI`,

  Виберіть **за замовчуванням** (клавіша `A`)

- та будь-які SSDT, пов’язані з підсвічуванням, необхідні на сторінці [NootedRed](/uk/applehax/nootedred/).

<details>
<summary>Приклад процедури</summary>
На основі ASRock B550m Phantom.

![SSDTTime FakeEC Result](~/assets/SSDTTime_FakeEC_Result.png)
![SSDTTime USBX Prompt](~/assets/SSDTTime_USBX_Prompt.png)
![SSDTTime USBX Result](~/assets/SSDTTime_USBX_Result.png)
![SSDTTime PluginType Result](~/assets/SSDTTime_PluginType_Result.png)
![SSDTTime RTCAWAC Result](~/assets/SSDTTime_RTCAWAC_Result.png)
![SSDTTime USB Reset Result](~/assets/SSDTTime_USBReset_Result.png)
![SSDTTime XOSI Prompt](~/assets/SSDTTime_XOSI_Prompt.png)
![SSDTTime XOSI Result](~/assets/SSDTTime_XOSI_Result.png)

</details>

## Копіювання файлів AML з папки Results

Папка `Results` буде схожа на наведену нижче після завершення.

![SSDTTime Results](~/assets/SSDTTimeResults.png)

Тепер скопіюйте всі файли, які починаються з `SSDT` та закінчуються на `.aml` всередині кореня папки `Results` до `Drive/EFI/OC/ACPI`.

### Злиття патчів OC за допомогою PatchMerge

Нарешті, злийте `patches_OC.plist`, використовуючи скрипт `PatchMerge`, включений до `SSDTTime`. Запустіть його так само, як `SSDTTime`.

![PatchMerge](~/assets/PatchMerge.png)

Натисніть `1`, щоб вибрати `Config.plist`, створений на попередньому кроці, потім перетягніть і скиньте свій `Config.plist` у вікно та натисніть Enter.

![PatchMerge after selecting the `Config.plist`](~/assets/PatchMerge_AfterSelect.png)

Після цього натисніть `2`, щоб розпочати процес злиття.

![PatchMerge after running the merge process](~/assets/PatchMerge_Result.png)

Змінений `Config.plist` зі злиттям патчів з’явиться в папці `Results`.

Перевірте, чи все гаразд, а потім замініть свій оригінальний `Config.plist` на новостворений.
