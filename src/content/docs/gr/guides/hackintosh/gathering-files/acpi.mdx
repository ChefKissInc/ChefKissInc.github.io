---
title: ACPI
description: SSDTs για προσθήκη στο Hackintosh EFI σας.
---

import Aside from '~/components/Aside.astro';

<Aside type="tip">
`Προηγμένη Διεπαφή Διαμόρφωσης και Ισχύος` (ACPI) είναι ένα ανοιχτό πρότυπο που μπορούν να χρησιμοποιούν τα λειτουργικά συστήματα για να ανακαλύπτουν και να διαμορφώνουν τα εξαρτήματα υλικού του υπολογιστή, να εκτελούν διαχείριση ενέργειας (π.χ. απενεργοποίηση ενός ελεγκτή USB), αυτόματη διαμόρφωση (π.χ. «Plug and Play», «hot plug») και παρακολούθηση κατάστασης.

Οι κατασκευαστές μπορούν να κάνουν ελέγχους λειτουργικού συστήματος, κάτι που συνήθως γίνεται για να απενεργοποιήσουν ορισμένες συσκευές και άλλες λειτουργίες σε λειτουργικά συστήματα που δεν σκοπεύουν να υποστηρίξουν.

Ο κύριος πίνακας ACPI είναι ο `DSDT` (Πίνακας Περιγραφής Διαφοροποιημένου Συστήματος), που ορίζει τις περισσότερες από τις συσκευές. Στη συνέχεια, υπάρχουν οι `SSDT`s (Δευτερεύοντες Πίνακες Περιγραφής Συστήματος), που προσθέτουν επιπλέον ιδιότητες (π.χ. τη μέθοδο `_PRW` (Πόροι Ισχύος για Αφύπνιση)), επιπλέον συσκευές, απενεργοποίηση ορισμένων συσκευών βάσει μιας συνθήκης, κ.λπ.

Τα περισσότερα υλικολογισμικά ορίζουν τις συσκευές στον `DSDT` και χρησιμοποιούν κάποιες `SSDTs` για να προσαρμόσουν τις τιμές ανάλογα με το εγκατεστημένο υλικό και/ή τις ρυθμίσεις του BIOS. Αν σας ενδιαφέρει το ACPI, μπορείτε να διαβάσετε την Προδιαγραφή ACPI που αναφέρεται στις προδιαγραφές του [UEFI Forum specifications](https://uefi.org/specifications).

</Aside>

## Λήψη του SSDTTime

<Aside type="note" title="Το ήξερες;">
Παλιά, αυτά τα SSDTs έπρεπε να γραφτούν χειροκίνητα, αλλά τώρα υπάρχουν αυτοματοποιημένα εργαλεία για αυτή τη διαδικασία. [`SSDTTime`](https://github.com/corpnewt/SSDTTime) will be used by this guide.
</Aside>

Επειδή το `SSDTTime` δεν έχει καμία έκδοση και είναι ένα έργο Python, κατεβάστε τον πηγαίο κώδικα κάνοντας κλικ στο `Code` και μετά στο `Download ZIP`.

![SSDTTime σελίδα λήψης](~/assets/SSDTTimeDownload.png)

## Εκτέλεση του SSDTTime

Μετά την εξαγωγή του αρχείου, οι χρήστες με Windows θα πρέπει να εκτελέσουν το `SSDTTime.bat`.

Οι χρήστες με Linux θα πρέπει να ανοίξουν την γραμμή εντολών τους μέσα στον αποσυμπιεσμένο κατάλογο `SSDTTime`/`SSDTTime-master` και στη συνέχεια να εκτελέσουν το `python3 SSDTTime.py`. **Βεβαιωθείτε ότι έχετε εγκαταστήσει το Python 3.**

Οι χρήστες με macOS θα πρέπει να εκτελέσουν το `SSDTTime.command`.

Κατά την εκκίνηση του εργαλείου, θα κατεβάσει αυτόματα το `iASL`, το οποίο (απο)μεταγλωττίζει τους πίνακες ACPI. Στη συνέχεια, θα πρέπει να δείτε την ακόλουθη οθόνη.

![SSDTTime Γραμμή εντολών](~/assets/SSDTTimeConsole.png)

### Καθορισμός του ACPI του συστήματος προορισμού


Επιλέξτε την επιλογή `P` στο σύστημα προορισμού για να αποθηκεύσετε τους πίνακες ACPI που χρειάζονται για τις λειτουργίες του `SSDTTime`.

Αν δεν εκτελείτε το `SSDTTime` στο σύστημα προορισμού, επιλέξτε `D` για να επιλέξετε τον φάκελο με τους πίνακες ACPI που αποθηκεύτηκαν από το σύστημα προορισμού.

Το λογισμικό θα πρέπει τώρα να εμφανίζει τους φορτωμένους πίνακες ACPI στην κορυφή, όπως φαίνεται στο παρακάτω στιγμιότυπο οθόνης.

![SSDTTime](~/assets/SSDTTimeConsole_ACPILoaded.png)

### Δημιουργία των SSDTs

<Aside type="note">
Οι περισσότερες από αυτές τις διορθώσεις θα εφαρμόζονται μόνο στο macOS και δεν θα πρέπει να προκαλούν παρενέργειες σε άλλα λειτουργικά συστήματα.
</Aside>

<details>
<summary>Πληροφορίες για τις επιλογές</summary>

Τη στιγμή της συγγραφής, υπάρχουν 12 διαθέσιμες επιλογές

- `FixHPET`

  Διορθώνει τις συγκρούσεις IRQ (Αίτημα Διακοπής) στους πίνακες ACPI. Αυτές οι συγκρούσεις μπορεί να προκαλέσουν προβλήματα σε ορισμένο υλικό, όπως ο ήχος. 
  
  <Aside type="danger">
  Μην χρησιμοποιείτε αυτήν την επιλογή σε AMD, καθώς μπορεί να προκαλέσει περισσότερα προβλήματα (π.χ. δεν δουλέβι η συσκευή αφής).
  </Aside>

- `FakeEC`

  Δημιουργεί μια ψεύτικη συσκευή Ενσωματωμένου Ελεγκτή για να λειτουργήσει σωστά το macOS **και** απενεργοποιεί τον αρχικό EC.

- `FakeEC Laptop`

  Δημιουργεί μια ψεύτικη συσκευή Ενσωματωμένου Ελεγκτή για να λειτουργήσει σωστά το macOS, **αλλά δεν** απενεργοποιεί τον αρχικό EC, επειδή τα laptop τον χρειάζονται για την κατάσταση της μπαταρίας, τα πλήκτρα FN, κ.λπ.

- `USBX`

  Δημιουργεί μια συσκευή USBX που περιέχει ιδιότητες ισχύος USB απαραίτητες για τη σωστή λειτουργία. Αυτό απαιτεί επίσης μια έγκυρη συσκευή EC.

- `PluginType`

  Ορίζει την ιδιότητα `plugin-type` σε `1` στον πρώτο πυρήνα της CPU, ενεργοποιώντας το `X86PlatformPlugin`, το οποίο επιτρέπει τη διαχείριση ισχύος του CPU και του GPU (η υποστήριξη διαφέρει). Επίσης, επαναπροσδιορίζει τους επεξεργαστές με αντικείμενα `Processor` αντί για αντικείμενα `Device` αν απαιτείται, καθώς το macOS δεν υποστηρίζει το νεότερο πρότυπο.

- `PMC`

  Ορίζει τη συσκευή `PMCR` σε συστήματα που δεν την έχουν για να επιτρέψει την εγγενή υποστήριξη `NVRAM`.

- `RTCAWAC`

  Απενεργοποιεί το νέο `AWAC` (Ρολόι Συναγερμού ACPI) και ενεργοποιεί το `RTC` (Ρολόι Πραγματικού Χρόνου).

- `USB Reset`

  Απενεργοποιεί τις συσκευές `RHUB` στο ACPI για όλους τους ελεγκτές USB ώστε το macOS να απαριθμήσει σωστά τις θύρες USB σε συστήματα με προβληματικό ACPI.

- `PCI Bridge`

  Ορίζει τις γέφυρες PCI για μια καθορισμένη διαδρομή συσκευής, καθώς ορισμένες συσκευές μπορεί να μην έχουν τις γέφυρες PCI ορισμένες, γεγονός που θα κάνει το OpenCore ανίκανο να εισάγει ιδιότητες χρησιμοποιώντας το κλειδί `DeviceProperties` στη διαμόρφωση.

- `PNLF`

  Δημιουργεί μια ψεύτικη συσκευή `PNLF` με επιλέξιμο `_UID` (ουσιαστικά το προφίλ που χρησιμοποιεί) για να επιτρέψει τον εγγενή έλεγχο φωτεινότητας σε laptops.

  <Aside type="danger">
  Με την πρώτη ματιά μπορεί να φαίνεται ότι υποστηρίζει laptop AMD, αλλά δεν είναι το ίδιο με αυτό στη σελίδα NootedRed. 
  Χρησιμοποιήστε αυτό στη σελίδα που αναφέρθηκε.
  </Aside>

- `XOSI`

  Παραποιεί το λειτουργικό σύστημα σε Windows, επιτρέποντας σε οποιαδήποτε περιφερειακά κλειδωμένα πίσω από μη macOS να είναι ενεργά στο macOS.

- `Fix DMAR`

  Αφαιρεί τις Κρατημένες Περιοχές Μνήμης από τον πίνακα `DMAR`. Απαιτείται για να λειτουργήσουν ορισμένες συσκευές όπως οι ελεγκτές ethernet Intel I225 σε συστήματα Intel.

  <Aside type="danger">
  Αν ήδη χρησιμοποιείτε macOS 12.2.1 και κάτω και έναν ελεγκτή ethernet Intel I225, θα χρειαστεί να αφαιρέσετε το `e1000=0` ή `dk.e1000=0` από τα boot-args αφού κάνοντας αυτό.
  </Aside>

</details>

**_Όλα_** τα συστήματα πρέπει να επιλέξουν τα παρακάτω

- `USBX`,

  Επιλέξτε την **προεπιλεγμένη** επιλογή (`B` πλήκτρο).

- `RTCAWAC`,

  Αν λέει ότι δεν το χρειάζεστε, παραλείψτε αυτό το SSDT.

- `PluginType`,
- και `USB Reset`.

Οι AMD **_επιτραπέζιοι υπολογιστές_** πρέπει **επίσης** να επιλέξουν τα εξής

- `FakeEC`.

Οι AMD **_φορητοί υπολογιστές_** πρέπει **επίσης** να επιλέξουν τα εξής

- `FakeEC Laptop`,
- `XOSI`,

  Επιλέξτε **προεπιλογή** (`A` πλήκτρο)

- και οποιαδήποτε SSDTs που σχετίζονται με τον οπίσθιο φωτισμό απαιτούνται στη σελίδα [NootedRed](/gr/applehax/nootedred/).

<details>
<summary>Example procedure</summary>
Based on an ASRock B550m Phantom.

![SSDTTime FakeEC Αποτέλεσμα](~/assets/SSDTTime_FakeEC_Result.png)
![SSDTTime USBX Eντολή](~/assets/SSDTTime_USBX_Prompt.png)
![SSDTTime USBX Αποτέλεσμα](~/assets/SSDTTime_USBX_Result.png)
![SSDTTime PluginType Αποτέλεσμα](~/assets/SSDTTime_PluginType_Result.png)
![SSDTTime RTCAWAC Αποτέλεσμα](~/assets/SSDTTime_RTCAWAC_Result.png)
![SSDTTime USB Reset Αποτέλεσμα](~/assets/SSDTTime_USBReset_Result.png)
![SSDTTime XOSI Εντολή](~/assets/SSDTTime_XOSI_Prompt.png)
![SSDTTime XOSI Αποτέλεσμα](~/assets/SSDTTime_XOSI_Result.png)

</details>

## Αντιγραφή των αρχείων AML από τον φάκελο Αποτελεσμάτων

Ο φάκελος `Results` θα μοιάζει με τον παρακάτω αφού τελειώσετε.

![SSDTTime Results](~/assets/SSDTTimeResults.png)

Τώρα, αντιγράψτε όλα τα αρχεία που ξεκινούν με `SSDT` και τελειώνουν σε `.aml` μέσα στη ρίζα του φακέλου `Results` στο `Drive/EFI/OC/ACPI`.

### Συγχώνευση των OC patches χρησιμοποιώντας το PatchMerge

Τέλος, συγχωνεύστε το `patches_OC.plist` χρησιμοποιώντας το σενάριο `PatchMerge` που περιλαμβάνεται με το `SSDTTime`. Εκτελέστε το με τον ίδιο τρόπο όπως το `SSDTTime`.

![PatchMerge](~/assets/PatchMerge.png)

Πατήστε `1` για να επιλέξετε το `Config.plist` που δημιουργήθηκε σε ένα προηγούμενο βήμα, στη συνέχεια σύρετε και αποθέστε το `Config.plist` στο παράθυρο και πατήστε enter.

![PatchMerge μετά την επιλογή του `Config.plist](~/assets/PatchMerge_AfterSelect.png)

Μετά, πατήστε `2` για να ξεκινήσετε τη διαδικασία συγχώνευσης.

![PatchMerge μετά την εκτέλεση της διαδικασίας συγχώνευσης](~/assets/PatchMerge_Result.png)

Το τροποποιημένο `Config.plist` με τις συγχωνευμένες διορθώσεις θα εμφανιστεί στον φάκελο `Results`.

Ελέγξτε ότι είναι εντάξει, στη συνέχεια αντικαταστήστε το αρχικό σας `Config.plist` με το νέο που δημιουργήθηκε.
